1. cd относится к типу встроенных команд. Об этом говорит вывод команды type cd
cd is a shell builtin
Встроенные команды являются частью shell, поэтому выполняются самостоятельно, не вызывая отдельного исполняемого файла. 
Такой тип команд необходим для управления средой и потоком программы текущего сеанса шелла. Внешняя утилита не сможет это сделать. Думаю все дело в том, что когда обычная команда запускается из определенного каталога, то дочерний процесс наследует родительский каталог. cd не порождает отдельный процесс, иначе бы этот процесс закончился бы прежде, чем каталог поменялся. Так как дочерний процесс не может изменить рабочий каталог для родительского. Вместо этого вызывая функции типа cd shell меняет свой собственный каталог.

2. Вместо grep <some_string> <some_file> | wc -l можно использовать специальный ключ -с --count который так же может подсчитать количество строк
grep <some_string> <some_file> -с

3. systemd

4. ls >/dev/pts/1 2>&1 

5. Получилось cat < Readme > readme1
vagrant@vagrant:~$ cat Readme
test
test1
vagrant@vagrant:~$ cat readme1
Readme
readme1
test
vagrant@vagrant:~$ cat Readme
test
test1
vagrant@vagrant:~$ cat < Readme > readme1
vagrant@vagrant:~$ cat Readme
test
test1
vagrant@vagrant:~$ cat readme1
test
test1

6. Без физического доступа к линуксу это казалось малореальным, но оказывается возможно. Можно подключиться к vagrant через консоль виртуалбокса, запустив эмулятор аппаратного терминала через Ctrl+Alt+F(1-6), у меня F3
И параллельно запустив ссесию из терминала или ssh
Затем из эмулятора терминала запускаем
vagrant@vagrant:~$ tty
/dev/tty3
Из консоли 
vagrant@vagrant:~$ tty
/dev/pts/0
Затем пытаемся послать вывод моего файла Readme из консоли в эмулятор
vagrant@vagrant:~$ cat Readme > /dev/tty3
и получаем ответ от эмулятора
vagrant@vagrant:~$ test
test1
Обратно из эмулятора в консоль сразу не получилось, но вернувшись в графику Ctrl+Alt+F1 и обратно Ctrl+Alt+F3 получилось (возможно vagrant немного глючный)
эмулятор:
vagrant@vagrant:$ cat Readme > /dev/pts/0 
консоль:
vagrant@vagrant:~$ test
test1

7. командой bash 5>&1 мы создаем новый файловый дискриптор 5 и перенаправляем его в stdout (1). Командой  echo netology > /proc/$$/fd/5 мы в этот дискриптор отправляем netology, который получаем в выводе (stdout)

8. vagrant@vagrant:~$ cat /var/log/messages 6>&2 2>&1 1>&6 | grep file -H
(standard input):cat: /var/log/messages: No such file or directory
6>&2 - создали новый файловый дискриптор 6 и перенаправили его в stderr (2)
2>&1 - перенаправили поток stderr в stdout
1>&6 - перенаправили stdout в новый файловый дискриптор
В итоге в качестве входного потока pipe получил stderr через промежуточный дискриптор

9. Команда cat /proc/$$/environ выводит переменные окружения. Таким же образом можно использовать команду env или set

10. /proc/<PID>/cmdline Этот доступный только для чтения файл содержит полную командную строку для процесса, если только процесс не является зомби. В последнем случае в этом файле ничего нет: то есть чтение этого файла вернет 0 символов. Аргументы командной строки появляются в этом файле как набор строк, разделенных нулевыми байтами ('\ 0') с дополнительным нулевым байтом после последней строки.
/proc/<PID>/exe
В Linux 2.2 и более поздних версиях этот файл представляет собой символическую ссылку, содержащую фактический путь к исполняемой команде. Эту символическую ссылку можно разыменовать обычным образом; попытка открыть его откроет исполняемый файл. Вы даже можете ввести / proc / [pid] / exe, чтобы запустить еще одну копию того же исполняемого файла, который запускается процессом [pid]. Если имя пути было отключено, символическая ссылка будет содержать строку «(удалено)», добавленную к исходному имени пути. В многопоточном процессе содержимое этой символической ссылки недоступно, если основной поток уже завершен (обычно путем вызова pthread_exit (3)).
Разрешение на разыменование или чтение (readlink (2)) этой символической ссылки регулируется проверкой режима доступа ptrace PTRACE_MODE_READ_FSCREDS; см. ptrace (2).

11. vagrant@vagrant:~$ grep sse /proc/cpuinfo
flags           : fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush mmx fxsr sse sse2 ht syscall nx rdtscp lm constant_tsc rep_good nopl xtopology nonstop_tsc cpuid tsc_known_freq pni pclmulqdq ssse3 cx16 pcid
sse4_1 sse4_2 x2apic movbe popcnt aes xsave avx rdrand hypervisor lahf_lm abm invpcid_single pti fsgsbase avx2 invpcid md_clear flush_l1d
flags           : fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush mmx fxsr sse sse2 ht syscall nx rdtscp lm constant_tsc rep_good nopl xtopology nonstop_tsc cpuid tsc_known_freq pni pclmulqdq ssse3 cx16 pcid
sse4_1 sse4_2 x2apic movbe popcnt aes xsave avx rdrand hypervisor lahf_lm abm invpcid_single pti fsgsbase avx2 invpcid md_clear flush_l1d
Самая старшая это sse4_2

12. По умолчанию tty для удаленной сессии не выделяется, но если использовать ключ -t, то поведение поменяется  
vagrant@vagrant:~$ ssh -t localhost 'tty'
vagrant@localhost's password:
/dev/pts/4
Connection to localhost closed.

13. В теории все понятно, документацию я прочла. Но из-за множества ошибок и ушедшего на исправление их время, я наверное не стану использовать этот продукт и рекомендовать его тоже. К тому же исправление ошибок указанных в документации просто приводят к другим сообщениям об ошибках. Ну может конечно он с vagrant не работает... Но проверить этот факт не на чем.
Все же добила этот reptyr, работает. Непонятно как будет работать с более менее серьезными и тяжелыми приложениями. 

14. Команда tee в Linux считывает стандартный ввод и записывает его одновременно в стандартный вывод и в один или несколько подготовленных файлов. При обычном перенаправлении потока вывода строки команды будут записаны в файл, но мы не сможем увидеть вывод одновременно. С помощью команды tee мы можем это сделать.
