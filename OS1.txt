1. Думаю, системный вызов для cd это 
chdir("/tmp")

2. База данных команды file /usr/share/misc/magic.mgc, так как вывод strace указал в том числе этот файл
openat(AT_FDCWD, "/usr/share/misc/magic.mgc", O_RDONLY) = 3
Гугл подтвердил предположение.

3. Открыла файл Readme с помощью vim (первоначально использовала nano, но в выводе lsof имя файла не было обнаружено, вероятно особенность работы nano)
Нашла PID процесса
vagrant@vagrant:~$ lsof | grep vim
vim       1767                        vagrant    5u      REG              253,0    12288     131097 /home/vagrant/.Readme.swp
Удалила файл Readme
Так как нам известен PID и файловый дискриптор, то можно в этот дискриптор положить любое значение, обнулив или уменьшив размер занимаемого места
vagrant@vagrant:~$ echo 'test' > /proc/1767/fd/5

4. Зомби не занимают памяти (как процессы-сироты), но блокируют записи в таблице процессов, размер которой ограничен для каждого пользователя и системы в целом.
При достижении лимита записей все процессы пользователя, от имени которого выполняется создающий зомби родительский процесс, не будут способны создавать новые дочерние процессы. Кроме этого, пользователь, от имени которого выполняется родительский процесс, не сможет зайти на консоль (локальную или удалённую) или выполнить какие-либо команды на уже открытой консоли (потому что для этого командный интерпретатор sh должен создать новый процесс), и для восстановления работоспособности (завершения виновной программы) будет необходимо вмешательство системного администратора.

5. vagrant@vagrant:~$ sudo opensnoop-bpfcc
PID    COMM               FD ERR PATH
775    vminfo              4   0 /var/run/utmp
593    dbus-daemon        -1   2 /usr/local/share/dbus-1/system-services
593    dbus-daemon        18   0 /usr/share/dbus-1/system-services
593    dbus-daemon        -1   2 /lib/dbus-1/system-services
593    dbus-daemon        18   0 /var/lib/snapd/dbus-1/system-services/

6. Цитата из man 2 uname
Part of the utsname information is also accessible via /proc/sys/kernel/{ostype, hostname, osrelease, version, domainname}.

7. && - логический оператор 
; - это простая последовательность.
В test -d /tmp/some_dir && echo Hi, echo Hi будет запущен, только если test -d /tmp/some_dir завершается с успешным кодом возврата.
В  test -d /tmp/some_dir; echo Hi,  echo Hi будет работать независимо от состояния выхода test -d /tmp/some_dir (при условии, что вы не настроили свою оболочку на выход при всех сбоях в вашем скрипте или чем-то еще).

8. Насколько я поняла, то наоборот, set -e не имеет смысла применять, если используется bash &&
Если по команде s e t -е установлен режим завершения, то выход
из оболочки происходит при неудачном завершении конвейера,
который может состоять из единственной команды; отдельной
команды подоболочки, заключенной в круглые скобки; или же
любой команды из группы, заключенной в фигурные скобки.
Неудачное завершение команды (с ненулевым кодом) не
приводит к выходу из оболочки в следующих случаях.
1. В списке, который следует после цикла while или u n til,
имеется любая команда.
2. После условного оператора i f или е 1 i f следует конвейер.
3. В логической операции && или | | имеется любая команда,
кроме последней.
4. В конвейере имеется любая команда, кроме последней.
5. Назначение команды меняется на обратное с помощью
знака !.
В общем, опытные программирующие на языке оболочки
считают, что на практике команда set -е редко и едва ли вообще
находит применение. Она существует лишь ради исторической
совместимости, и поэтому вместо нее лучше тщательно
программировать, чтобы отлавливать любые или все ошибки,
которые могут возникнуть в принципе.

8. Опции: 
-е Завершить команду, если она выдает ненулевой код завершения. Перед выходом
из оболочки выполняется прерывание ERR.
-u Интерпретировать при подстановках неустановленные переменные как
ошибки. Тем не менее ссылки на переменные $ @ и $ * не считаются ошибками
в отсутствие позиционных параметров
-x Отображать команды вместе с их аргументами, когда они выполняются, предваряя
их приглашением из переменной PS4. Этим обеспечивается пошаговая
трассировка сценариев оболочки
-о [режим]
Перечислить все режимы работы оболочки или активизировать заданный
режим. Многие режимы работы оболочки могут быть также установлены
с помощью других параметров данной команды.
-o pipefail 
Режим pipefail - заменить код завершения конвейера на код завершения
последней неудачно завершившейся команды или нулевой
код завершения, если все команды в конвейере завершились
удачно
В сценариях режим set -euxo pipefail удобен тем, что все шаги последовательно обрабатываются и выводятся на консоль, что удобно отследить в случае возникновения ошибок где они произошли.

9. vagrant@vagrant:~$ ps -o stat
STAT
Ss
R+
Наиболее часто встречающийся статус - Ss
Он означает (согласно man ps /PROCESS STATE CODES), что S - interruptible sleep (waiting for an event to complete) в сочетании с s is a session leader
За ним идет второй по значимости и последний на моей системе R+
Он означает R    running or runnable (on run queue) и +    is in the foreground process group





